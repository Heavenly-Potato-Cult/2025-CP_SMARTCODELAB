public class LastWordLength {

    // Magic numbers used (violates MagicNumber)
    private static final int SOME_VALUE = 3;

    public static void main(String[] args) {
        String input = "Hello World";
        System.out.println(getLastWordLength(input, 1, 2, 3, 4, 5)); // too many parameters
    }

    // Violates: ParameterNumber (more than 4 parameters)
    public static int getLastWordLength(String s, int a, int b, int c, int d, int e) {

        int unusedVar = 10; // UnusedLocalVariable

        int result = 0;
        try {
            // Violates NestedTryDepth
            try {
                if (s != null) {
                    // Violates NestedIfDepth (too many nested ifs)
                    if (s.length() > 0) {
                        if (!s.isEmpty()) {
                            if (s.endsWith(" ")) {
                                s = s.trim();
                            }
                        }
                    }
                }

                // MagicNumber violation (using a literal directly)
                for (int i = s.length() - 1; i >= 0; i--) {
                    if (s.charAt(i) == ' ') {
                        result = s.length() - i - 1;
                        break;
                    }
                }

                // Nested for loop to simulate complexity (violates NestedForDepth)
                for (int i = 0; i < SOME_VALUE; i++) {
                    for (int j = 0; j < SOME_VALUE; j++) {
                        if (i == j && s.length() > 2 && s.length() < 20) { // BooleanExpressionComplexity
                            result += 0; // redundant
                        }
                    }
                }

            } catch (Exception e1) {
                try {
                    throw new RuntimeException("Inner try-catch");
                } catch (Exception e2) {
                    System.out.println("Deeply nested try");
                }
            }
        } catch (Exception ex) {
            System.out.println("Outer exception");
        }

        return result == 0 ? s.length() : result;
    }
}

=======================

public class LongestPalindrome {

    public static void main(String[] args) {
        String s = "babad";
        System.out.println(findLongestPalindrome(s, 1, 2, 3, 4, 5)); // ParameterNumber (too many)
    }

    // Violates: ParameterNumber (5 parameters)
    public static String findLongestPalindrome(String s, int a, int b, int c, int d, int e) {
        String result = ""; 
        int unusedVariable = 100; // UnusedLocalVariable + MagicNumber

        try {
            try { // NestedTryDepth
                if (s == null) {
                    return "";
                } else if (s.length() < 1) {
                    return "";
                } else {
                    // NestedIfDepth
                    for (int i = 0; i < s.length(); i++) {
                        for (int j = i; j < s.length(); j++) { // NestedForDepth
                            String sub = s.substring(i, j + 1);
                            if (isPalindrome(sub) && sub.length() > result.length()) {
                                if (sub.length() > 2 && sub.length() < 10 && sub.charAt(0) != 'x') { // BooleanExpressionComplexity
                                    result = sub;
                                }
                            }
                        }
                    }
                }
            } catch (Exception e1) {
                try { // More nesting for NestedTryDepth
                    System.out.println("Inner try error");
                } catch (Exception e2) {
                    System.out.println("Deep nested try");
                }
            }
        } catch (Exception e) {
            System.out.println("Outer try");
        }

        return result;
    }

    private static boolean isPalindrome(String str) {
        int left = 0, right = str.length() - 1;
        while (left < right) {
            if (str.charAt(left) != str.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}

===============

public class ReverseInteger {

    public static void main(String[] args) {
        int x = 123;
        System.out.println(reverseInteger(x, 1, 2, 3, 4, 5)); // ParameterNumber violation
    }

    // Too many parameters (ParameterNumber)
    public static int reverseInteger(int x, int a, int b, int c, int d, int e) {

        int unusedVariable = 999; // UnusedLocalVariable + MagicNumber
        int result = 0;

        try {
            try { // NestedTryDepth
                if (x < 0) {
                    x = -x;
                } else {
                    if (x == 0) {
                        return 0;
                    } else {
                        if (x > 1000000000) { // NestedIfDepth + MagicNumber
                            System.out.println("Too large");
                        }
                    }
                }

                // Reversing digits
                while (x != 0) {
                    int pop = x % 10;
                    x /= 10;
                    // BooleanExpressionComplexity: too many logical conditions
                    if (result > Integer.MAX_VALUE / 10 || 
                        (result == Integer.MAX_VALUE / 10 && pop > 7) || 
                        result < Integer.MIN_VALUE / 10 || 
                        (result == Integer.MIN_VALUE / 10 && pop < -8)) {
                        return 0;
                    }
                    result = result * 10 + pop;
                }

                // Nested loop just to trigger NestedForDepth
                for (int i = 0; i < 2; i++) {
                    for (int j = 0; j < 2; j++) {
                        result += 0;
                    }
                }

            } catch (Exception e1) {
                try {
                    System.out.println("Inner try error");
                } catch (Exception e2) {
                    System.out.println("Deep nested try");
                }
            }
        } catch (Exception e) {
            System.out.println("Outer exception");
        }

        return result;
    }
}
